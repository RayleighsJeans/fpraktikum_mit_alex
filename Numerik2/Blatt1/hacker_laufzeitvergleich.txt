QUELLCODE

#####################################################################################################################################################################

function [] = hacker_laufzeitvergleich(laufweiten)

    warning off;            %Gebrabbel aus dem Hintergrund AUS.

    %Es wird für die im Vektor 'laufweiten' definierten ganzen Zahlen jeweils
    %eine Tridiagonalmatrix der entsprechenden Dimension n erstellt. Auf deren
    %Diagonalelementen stehen (von oberer Diagonalen zur unteren): -1,2,-1.
    %Die Initialisierung dieser wird nach dem Vorbild von 'tridiag.m'
    %vorgenommen.
        
    fprintf('Zuerst für volle Matrizen!\n')
for n = laufweiten;                  %Schleife über alle angegeben Laufweiten.
    
    A = zeros(n);                    %Initialisierung/Bereitstellung des Platzes der verwendeten Objekte (A,B,x,b).
    B = zeros(n);
    
    x = zeros(n,1);
    
    b = zeros(n,1);
    
    A = diag(ones(n-1,1),1);         %Diagonalmatrix A (Hauptdiagonale 1)
    
    B = 2.*eye(n)-A-A';              %B ist die benutzte Matrix mit -1,2,-1 auf den Diagonalen. eye(n) ist Eins-Element der nxn-Matrizen. A' ist das Transponierte von A, woraus die gewünschte Form von B folgt
    
    b = 10.*rand(n,10);              %Zufallsvektor b der Länge der Matrix-Dimension mit größtmöglichem Element 10
    
    tic;                             %Zeitmessung für die tatsächliche Rechnung des GLS beginnt.
    
    x = B\b;                         %Lösen des Gleichungssystems B*x=b.
    
    T = toc;                         %Zeitmessung stoppt und Variable T ist die gemessene Dauer.
    
    fprintf('Die Rechendauer für n=%d die Dimension des Systems betrug %.10f s\n', n, T);       %Ergebnisse auswerfen.
    
end

clear T;                             %Sicherheitshalber löschen der Zeit/en.

    fprintf('Jetzt für schwach besetze Matrizen!\n')
for n = laufweiten;
    
    A = zeros(n);
    C = zeros(n);                    %Zusätzliche Bereitstellung von Platz für die schwache besetzte Variante von B: C!
    B = zeros(n);
    
    x = zeros(n,1);
    
    b = zeros(n,1);
    
    A = diag(ones(n-1,1),1);
    
    B = 2.*eye(n)-A-A';
    
    b = 10.*rand(n,10);
    
    C = sparse(B);                   %C ist jetzt die 'gleiche' Matrix wie B, nur als sparse definiert!
    
    tic;
    
    x = C\b;
    
    T = toc;
    
    fprintf('Die Rechendauer für n=%d die Dimension des Systems betrug %.10f s\n', n, T);
    
end
    
    clear all;
    
end

##########################################################################################################################################################################

EINGABE:

hacker_laufzeitvergleich([1,10,100,1000,10000])

AUSGABE:

>> hacker_laufzeitvergleich([10,100,1000,10000])
Zuerst für volle Matrizen!
Die Rechendauer für n=10 die Dimension des Systems betrug 0.0003029315 s
Die Rechendauer für n=100 die Dimension des Systems betrug 0.0003903347 s
Die Rechendauer für n=1000 die Dimension des Systems betrug 0.0257942019 s
Die Rechendauer für n=10000 die Dimension des Systems betrug 6.6365603537 s
Jetzt für schwach besetze Matrizen!
Die Rechendauer für n=10 die Dimension des Systems betrug 0.0003165055 s
Die Rechendauer für n=100 die Dimension des Systems betrug 0.0004870079 s
Die Rechendauer für n=1000 die Dimension des Systems betrug 0.0003976183 s
Die Rechendauer für n=10000 die Dimension des Systems betrug 0.0031710139 s
>> 


Fazit:

Die Definition einer - bekannt schwach besetzten Matrix A - als B = sparse(A) spart für höhere Dimensionen merklich Rechenzeit, was die Optimierung von höherdimensionalen Gleichungssystemen ermöglicht.
Bei der angenommenen Genauigkeit (auf die 10te Stelle nach der 0) lässt sich für einen Faktor 10^3 zwischen den Schrittweiten keine Verlängerung der Laufzeit feststellen. Die Zeit 
zur Initialisierung des Problems und der Vermittlung an den Rechenapparat scheinen demnach groß gegen den tatsächlichen Aufwand zu sein.